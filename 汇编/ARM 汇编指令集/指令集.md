### 寻址方式

* `mov`
    * `mov r1, r2`  寄存器寻址
        * 将 r2 的值给到 r1
    * `mov r0, #0xFF00` 立即寻址
        * 将 #0xFF00 给到 r0 `# 代表是个数值`
    * `mov r0, r1, lsl #3` 寄存器移位寻址
        * 将 r1 左移 3 位后的值给到 r0 `lsl 左移`
* `ldr`
    * `ldr r1, [r2]` 寄存器间接寻址
        * 把 r2 存的内存地址给到 r1 `[r2] 表示一个内存地址`
    * `ldr r1, [r2, #4]` 基址变址寻址
        * 把 r2 存的内存地址 加 4 后给到 r1 `[r2, #4] 内存地址 加4`
* `ldmia`
    * `ldmia r1!, {r2-r7, r12}` 多寄存器寻址
        * 把 r1 当做一个数组首地址, 并把连续 7 个数组的值给到 r2 到 r7, r12 `r1! 表示数组首地址 {r2-r7, r12} 表示 r2...r7 r12 寄存器`
* `stmfd`
    * `stmfd sp!, {r2-r7, lr}` 堆栈寻址
        * 把堆栈指针 sp 作为一个数组首地址, 并把连续 7 个数组的值给到 r2 到 r7, lr `sp! 表示堆栈指针`

* `beq flag` 相对寻址
    * `flag:` beq 找到标号 flag: 开始执行代码

### 指令后缀

* `B (byte)` 功能不变, 操作长度变为8位
* `H (half word)` 功能不变, 操作长度为16位
* `S （signed)` 功能不变, 操作数变为有符号
    * 如 `ldr ldrb ldrh ldrsb ldrsh`
* `S (S标志)` 功能不变, 影响CPSR标志位
    * 如 `mov movs`

### 条件执行后缀

* `EQ` - `Z=1` 相等
* `NE` - `Z=0` 不相等
* `CS/HS` - `C=1` 无符号数大于或等于
* `CC/LO` - `C=0` 无符号数小于
* `MI` - `N=1` 负数
* `PL` - `N=0` 正数或零
* `VS` - `V=1` 溢出
* `VC` - `V=0` 没有溢出
* `HI` - `C=1,Z=0` 无符号数大于
* `LS` - `C=0,Z=1` 无符号数小于或等于
* `GE` - `N=V` 有符号数大于或等于
* `LT` - `N!=V` 有符号数小于
* `GT` - `Z=0,N=V` 有符号数大于
* `LE` - `Z=1,N!=V` 有符号数小于或等于
* `AL` - `任意` 无条件执行(指令默认条件)
* `NV` - `任意` 从不执行(不要使用)
    * 如 `moveq r0, r1` 条件后缀是否成立取决于上一句代码执行后 标志位的值

### 数据处理指令

* `mov mvn` 数据传输指令
    * `mov` 传值后数据保持不变
    * `mvn` 传值后数据按位取反
* `add sub rsb adc sbc rsc` 算术指令
* `and orr eor bic` 逻辑指令
    * `and` 逻辑与 &  
    * `orr` 逻辑或 |
    * `eor` 逻辑异或 ^
    * `bic` 清零 bic r0,r0,#0xf 把 r0 最后四位清零
* `cmp cmn tst teq` 比较指令
    * `cmp` - `cmp r0, r1` 等价于两个数相减 是否为0 (1 - 1)
    * `cmn` - `cmn r0, r1` 等价于两个数相加 是否为0 (1 + (-1))
    * `tst` - `tst r0, #0x8` 等价于 r0 and r1 测试 bit_3 是否为 0 - #0x8 = b1000 - 判断寄存器哪些位是否为0
    * `teq` - `teq r0, r1` 等价于 r0 eof r1 
    * 比较指令不用加 s 就可以影响 cpsr 中的标志位
* `mvl mla umull umlal smull smlal` 乘法指令
* `clz` 前导零计数
    * 看一个数前面有多少个零

### cpsr 访问指令

* `mrs` 用来读 psr
    * `mrs r0, cpsr` 把cpsr 读取到 r0
* `msr` 用来写 psr
    * `msr cpsr, r0` 把 r0 的值写入 cpsr
    * `msr cpsr_c, #0xd3` 把 #0xd3 写入 cpsr 的控制位

### 跳转(分支)指令

* `b` 直接跳转
* `bl` 跳转前把返回地址放入 lr 中, 以便返回, 以便用于函数调用
* `bx` 跳转同时切换到 arm 模式, 一般用于异常处理的跳转

### 访存指令

* `ldr/str & ldm/stm & swp`
    * `ldr/str` 单个字/半字/字节访问
    * `ldm/stm` 多字批量访问
        * `stmia sp, {r0-r12}`
            * 将 r0 存入 sp 指向的内存处(假设为0x30001000) 然后地址 +4 (即指向0x30001004) 将 r1 存入该地址 然后地址再 +4 ... 直到 r12 内容放入(0x3000130)指令完成
        * `ldmia r2, {r2 - r3}`
            * 把 r2 内存地址指向的值 放入 r2 并再把 r2地址加 4 的内存地址指向的值放入 r3
        * `ldmia r2!, {r2 - r3}`
            * 把 r2 内存地址指向的值 放入 r2 并再把 r2地址加 4 的内存地址指向的值放入 r3, 最后把r2 地址加4 的结果地址 返回 r2
        * `ldmfd sp!, {r0 -r6, pc}`
            * 把 sp 地址内的值放入 r0-r6 pc 内, 并把最后一位时的地址给到 sp
        * `ldmfd sp!, {r0 -r6, pc}^`
            * 把 sp 地址内的值放入 r0-r6 pc 内, 并把最后一位时的地址给到 sp
            * ^ 将 spsr 写入到 cpsr 中
        * 指令后缀
            * `ia` 先传输, 再地址 +4
            * `ib` 先地址 +4, 再传输
            * `da` 先传输, 再地址 -4
            * `db` 先地址 -4, 再传输
            * `fd` 满递减堆栈
            * `ed` 空递减堆栈
            * `fa` 满增减堆栈
            * `ea` 空增减堆栈
    * `swp r1, r2, [r0]`  把 r0 地址内的内容给到 r1 把 r1 的内容给到 r2
    * `swp r1, r1, [r0]`  把 r0 地址内的内容给到 r1 把 r1 的内容给到 r0

### 软中断指令

* `swi` 软中断指令用来实现操作系统中系统调用

### 协处理器 cp15 操作指令

* `mcr & mrc` cp 为协处理器
    * `mrc` 用于读取 cp15 中的寄存器
        * `mrc p15, 0, r0, c1, c0, 0` 将 c1 的数据读取到 r0 中进行操作
            * p15 就是 cp15
            * 0 永远是0
            * r1 cpu中的寄存器 - 不能是 r25-pc
            * c1 cp15的寄存器, 合法值是c0~c15
            * c0 cp15的寄存器, 一般均设为c0
            * 0 一般省略或为0
    * `mcr` 用于写入 cp15 中的寄存器
        * `mcr p15, 0, r0, c1, c0, 0` 将 r0 的数据读取到 c1 中进行操作
    
### 伪指令

* `.global _start` 给 _start 外部链接属性
* `.section .text` 指定当前端为代码段
* `.ascii .byte .short .long .word`
* `.quad .float .string` 定义数据
* `.align 4` 以16字节对齐 2的四次方
* `.balignl 16 0xabcdefgh` 16字节对齐填充
* `.equ` 类似于 C 中的宏定义

* `.end` 标识文件结束
* `.include` 头文件包含
* `.arm / .code32` 声明一下为 arm 指令
* `.thrumb / .code16` 声明一下为 thrumb 指令

* `ldr` 大范围的地址加载指令
    * ldr 指令 `ldr r0, #0xff`
    * ldr 伪指令 `ldr r0, =0xff`
* `adr` 小范围的地址加载指令
* `adrl` 中等范围的地址加载指令
* `nop` 空操作