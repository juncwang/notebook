### 寻址方式

* `mov`
    * `mov r1, r2`  寄存器寻址
        * 将 r2 的值给到 r1
    * `mov r0, #0xFF00` 立即寻址
        * 将 #0xFF00 给到 r0 `# 代表是个数值`
    * `mov r0, r1, lsl #3` 寄存器移位寻址
        * 将 r1 左移 3 位后的值给到 r0 `lsl 左移`
* `ldr`
    * `ldr r1, [r2]` 寄存器间接寻址
        * 把 r2 存的内存地址给到 r1 `[r2] 表示一个内存地址`
    * `ldr r1, [r2, #4]` 基址变址寻址
        * 把 r2 存的内存地址 加 4 后给到 r1 `[r2, #4] 内存地址 加4`
* `ldmia`
    * `ldmia r1!, {r2-r7, r12}` 多寄存器寻址
        * 把 r1 当做一个数组首地址, 并把连续 7 个数组的值给到 r2 到 r7, r12 `r1! 表示数组首地址 {r2-r7, r12} 表示 r2...r7 r12 寄存器`
* `stmfd`
    * `stmfd sp!, {r2-r7, lr}` 堆栈寻址
        * 把堆栈指针 sp 作为一个数组首地址, 并把连续 7 个数组的值给到 r2 到 r7, lr `sp! 表示堆栈指针`

* `beq flag` 相对寻址
    * `flag:` beq 找到标号 flag: 开始执行代码

### 指令后缀

* `B (byte)` 功能不变, 操作长度变为8位
* `H (half word)` 功能不变, 操作长度为16位
* `S （signed)` 功能不变, 操作数变为有符号
    * 如 `ldr ldrb ldrh ldrsb ldrsh`
* `S (S标志)` 功能不变, 影响CPSR标志位
    * 如 `mov movs`

### 条件执行后缀

* `EQ` - `Z=1` 相等
* `NE` - `Z=0` 不相等
* `CS/HS` - `C=1` 无符号数大于或等于
* `CC/LO` - `C=0` 无符号数小于
* `MI` - `N=1` 负数
* `PL` - `N=0` 正数或零
* `VS` - `V=1` 溢出
* `VC` - `V=0` 没有溢出
* `HI` - `C=1,Z=0` 无符号数大于
* `LS` - `C=0,Z=1` 无符号数小于或等于
* `GE` - `N=V` 有符号数大于或等于
* `LT` - `N!=V` 有符号数小于
* `GT` - `Z=0,N=V` 有符号数大于
* `LE` - `Z=1,N!=V` 有符号数小于或等于
* `AL` - `任意` 无条件执行(指令默认条件)
* `NV` - `任意` 从不执行(不要使用)
    * 如 `moveq r0, r1` 条件后缀是否成立取决于上一句代码执行后 标志位的值

### 数据处理指令

* `mov mvn` 数据传输指令
    * `mov` 传值后数据保持不变
    * `mvn` 传值后数据按位取反
* `add sub rsb adc sbc rsc` 算术指令
* `and orr eor bic` 逻辑指令
    * `and` 逻辑与 &  
    * `orr` 逻辑或 |
    * `eor` 逻辑异或 ^
    * `bic` 清零 bic r0,r0,#0xf 把最后四位清零
* `cmp cmn tst teq` 比较指令
* `mvl mla umull umlal smull smlal` 乘法指令
* `clz` 前导零计数